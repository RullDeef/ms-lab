#!/bin/octave -qf

pkg load statistics

X = [-0.45, -0.33, 2.92, -1.25, -1.20, 0.05, -0.53, -0.19, 1.49, 0.67, 0.22, 1.23, 0.50, -0.92, 0.90, -1.52, -0.15, -1.24, -0.47, -0.45, 0.18, -0.05, 1.58, 1.74, 2.37, -0.24, -1.34, 1.05, 1.28, 1.37, 1.18, 0.22, 0.11, 0.28, -0.64, -0.39, -1.77, -1.61, 0.47, 0.77, -0.27, -1.19, -0.25, 1.04, -0.16, 0.42, 0.29, 0.10, 1.04, 0.43, -0.67, 0.41, -0.62, -1.49, 1.46, -2.77, 2.09, 0.88, -0.36, -0.71, -0.62, 1.34, -0.78, -0.15, 2.69, 0.92, 1.68, -0.12, 0.34, 0.74, 1.72, 1.24, 0.23, 0.76, 0.87, -1.52, 0.63, -0.56, 0.83, 0.31, -0.18, 0.99, -1.01, 0.58, 1.21, -1.51, 0.65, 0.35, -0.37, -0.50, -0.73, 0.63, 0.33, 1.56, -0.98, 0.85, 0.56, -1.07, 1.47, 1.44, 1.91, 0.24, 1.34, 0.99, 1.27, 0.11, 0.22, -0.25, 0.35, -0.03, -0.56, -0.79, 2.41, -0.45, -0.44, 0.07, 0.64, 0.69, 0.10, -0.28];

#X = [105, 108, 108, 109, 109, 111, 111, 111, 112, 113, 114, 114, 115, 115, 115, 115, 115, 115, 115, 115, 116, 116, 116, 117, 117, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 119, 119, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 121, 121, 121, 122, 122, 122, 122, 122, 122, 123, 123, 123, 123, 123, 123, 123, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 126, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129, 129, 129, 129, 129, 129, 130, 130, 130, 130, 131, 131, 131, 131, 131, 131, 131, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 133, 133, 133, 133, 133, 133, 134, 134, 134, 134, 134, 134, 134, 135, 135, 135, 135, 135, 135, 135, 136, 136, 137, 137, 137, 137, 137, 138, 138, 139, 140, 140, 143, 144, 147, 147, 152];

N = length(X)

[M_min, M_max] = bounds(X)          # Минимальное и максимальное значения выборки
R = range(X)                        # Размах выборки

mu_hat = sum(X) / N                 # Среднее наблюдённое значение
S_2 = sum((X - mu_hat).^2) / (N-1)  # Оценка дисперсии

m = floor(log2(N)) + 2              # Количество интервалов
intv_delta = R / m                  # Размер интервала

intv = zeros(2, m + 2);                 # Интервалы
n = zeros(1, m + 2);                    # Частости значений в интервалах 

for k = 1:m+2
    intv(1, k) = M_min + (k - 1 - 1) * intv_delta;
    intv(2, k) = M_min + (k - 1) * intv_delta;
    n(1, k) = sum(intv(1, k) <= X & X < intv(2, k)) / intv_delta / N;
endfor;

n(1, m+2) = 0;

X_norm = linspace(M_min - R * 0.1, M_max + R * 0.1, 200);
Y_norm = 1 / (sqrt(2 * pi * S_2)) * exp(-((X_norm - mu_hat) .^ 2)/(2 * S_2));

stairs(intv(1, 1:m+2), n);            # Вывод ступенчатого графика функции плотности
hold on
plot(X_norm, Y_norm);               # Вывод графика функции плотности
hold off
pause;

n = zeros(1, N);
for k = 1:N
    t = sort(X)(k);
    n(1, k) = sum(X < t) / N;
endfor;

intv = zeros(2, m + 2);
n = zeros(1, m + 2);
for k = 1:m+2
    intv(1, k) = M_min + (k - 1 - 1) * intv_delta;
    intv(2, k) = M_min + (k - 1) * intv_delta;
    n(1, k) = sum(X < (intv(1, k) + intv(2, k)) / 2) / N;
endfor;

Y_norm = stdnormal_cdf((X_norm - mu_hat) / sqrt(S_2));

stairs(intv(1, 1:m+2), n);
#stairs(sort(X), n);            # Вывод эмпирической функции распределения
hold on
plot(X_norm, Y_norm);               # Вывод функции распределения
hold off
pause;
